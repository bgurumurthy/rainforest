#!/usr/bin/env python

import sys

if sys.version_info < (2, 7):
	raise Exception('Required python 2.7 or newer')

import boto.ec2
import time
import random
import numpy
import paramiko
import re

from argparse import ArgumentParser

INSTTYPES = [
	'm1.small',
	'm1.large',
	'm1.xlarge',
	't1.micro',
	'm2.xlarge',
	'm2.2xlarge',
	'm2.4xlarge',
	'c1.medium',
	'c1.xlarge',
	'cc1.4xlarge',
	'cg1.4xlarge',
]

IMAGES = {
	'm1.small':		'ami-e2af508b',
	'm1.large':		'ami-68ad5201',
	'm1.xlarge':	'ami-68ad5201',
	't1.micro':		'ami-8ddb1ae4',
	'm2.xlarge':	'ami-68ad5201',
	'm2.2xlarge':	'ami-68ad5201',
	'm2.4xlarge':	'ami-68ad5201',
	'c1.medium':	'ami-e2af508b',
	'c1.xlarge':	'ami-68ad5201',
	'cc1.4xlarge':	'ami-6fda1b06',
	'cg1.4xlarge':	'ami-6fda1b06'
}

def create_hash():
	random.seed()
	hash = random.getrandbits(32)
	return "%08X" % hash

def create_keypair(ec2, name):
	keypair = ec2.create_key_pair(name)
	dir = '/tmp'
	keypair.save(dir)
	path = "%s/%s.pem" % (dir, name)
	return { 'name': name, 'path': path, 'obj': keypair }

def create_security_group(ec2, name):
	group =  conn.create_security_group(name, 'Network benchmark group')
	group.authorize(src_group=group)
	group.authorize(ip_protocol='tcp', from_port='22', to_port='22', 
		cidr_ip='0.0.0.0/0')
	group.authorize(ip_protocol='tcp', from_port='80', to_port='80', 
		cidr_ip='0.0.0.0/0')
	group.authorize(ip_protocol='tcp', from_port='5001', to_port='5001', 
		cidr_ip='0.0.0.0/0')
	return { 'name': name, 'obj': group }

def create_instance(ec2, instancetype, image, keyname, secgroup, zone):
	reserv = ec2.run_instances(
				image, 
				key_name = keyname, 
				security_groups = [secgroup], 
				instance_type = instancetype, 
				placement = zone, 
				instance_initiated_shutdown_behavior = 'terminate')
	while len(reserv.instances) != 1:
		time.sleep(1)
	instance = reserv.instances[0]
	return instance

def is_instance_running(instance):
	return instance.update() == 'running'

def is_instance_terminated(instance):
	return instance.update() == 'terminated'

def terminate_instance(instance):
	instance.terminate()

def ssh_exec(ssh, cmd, wait=True):
	stdin, stdout, stderr = ssh.exec_command(cmd)
	status = 0
	if wait:
		channel = stdout.channel
		status = channel.recv_exit_status()
	return (stdout, stderr, status)

def install_iperf(ssh):
	stdout, stderr, status = ssh_exec(ssh, 'TERM=vt100 sudo apt-get install -qy iperf')
	return status

def start_iperf_server(ssh):
	stdout, stderr, status = ssh_exec(ssh, 'iperf -D -s', wait=False)

def keep_ssh_alive(ssh):
	stdout, stderr, status = ssh_exec(ssh, 'echo 1', wait=False)

def iperf(ssh, server):
	stdout, stderr, status = ssh_exec(ssh, "iperf -yc -t30 -c %s" % server)
	out = stdout.read().strip()
	err = stdout.read().strip()
	print "OUT = '%s', ERR = '%s', STATUS = %d" % (out, err, status)
	try:
		res = int(out.split(',')[-1])
		return res
	except:
		pass
	return None

def connect_ssh(instance, key):
	ssh = paramiko.SSHClient()
	ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
	try:
		ssh.connect(instance.dns_name, username='ubuntu', 
			key_filename=key, timeout=2)
		ssh.get_transport().set_keepalive(5)
	except:
		return None
	return ssh

def is_ssh_ready(instance, key):
	ssh = connect_ssh(instance, key)
	if ssh is None:
		return False
	try:
		stdout, stderr, status = ssh_exec(ssh, 'echo 1')
		out = stdout.read().strip()
		return out == '1'
	except:
		return False


####### MAIN #######
if __name__ == '__main__':
	parser = ArgumentParser(description='nothing')
	parser.add_argument('--access-key', required=True, help='AWS Access Key')
	parser.add_argument('--secret-key', required=True, help='AWS Secret Key')
	parser.add_argument('--region', required=True, help='AWS Region')
	parser.add_argument('--zone', required=True, help='AWS Zone')
	parser.add_argument('--version', action='version', version='0.0.1')
	args = parser.parse_args()

	# connect to EC2
	conn = boto.ec2.connect_to_region(
				args.region, 
				aws_access_key_id=args.access_key, 
				aws_secret_access_key=args.secret_key)

	# initialize
	hash = create_hash()

	name = 'kpnb_%s' % hash
	print "Creating keypair %s" % name
	keypair = create_keypair(conn, name)

	name = "sgnb_%s" % hash
	print "Creating security group %s" % name
	group = create_security_group(conn, name)

	print "Creating instances..."
	instances = []
	for it in INSTTYPES:
		print "\tCreating type %s, image %s... " % (it, IMAGES[it]),
		instance = create_instance(
			conn, it, IMAGES[it], 
			keypair['name'], group['name'], args.zone)
		print instance
		instances.append(instance)

	print "Waiting for all instances to be running and have ssh ready..."
	waiting = list(instances)
	while len(waiting) > 0:
		for instance in waiting:
			if not is_instance_running(instance):
				continue
			if not is_ssh_ready(instance, keypair['path']):
				continue
			instance.add_tag('Name', 'nb_%s' % hash)
			waiting.remove(instance)
			print "\t%s is ready, %d to go" % (instance, len(waiting))
		time.sleep(2)

	# save all connections here
	sshs = []

	# install iperf on all instances and start server
	print "Installing iperf and starting servers..."
	for instance in instances:
		print "\tCreating ssh connection to %s" % instance
		ssh = connect_ssh(instance, keypair['path'])
		print "\tInstalling iperf on %s" % instance
		install_iperf(ssh)
		print "\tStarting iperf on %s" % instance
		start_iperf_server(ssh)
		# save ssh conn
		sshs.append(ssh)

	# initialize sheet
	nit = len(INSTTYPES)
	sheet = numpy.empty(shape=(nit+1, nit+1), dtype=object)
	for i in range(0, nit):
		sheet[i+1, 0] = sheet[0, i+1] = INSTTYPES[i]

	# run iperf
	print "Running iperf..."
	for ci in range(0, nit):
		client = instances[ci]
		cssh = sshs[ci]
		for si in range(0, nit):
			server = instances[si]
			if client == server:
				continue
			print "\tRunning iperf from %s to %s... " % (client, server),
			result = iperf(cssh, server.dns_name)
			print result
			sheet[ci+1, si+1] = result

	# terminate all instances
	for instance in instances:
		print "Terminating instance %s" % instance
		terminate_instance(instance)

	# wait for all instances to be terminated
	print "Waiting instances to terminate..."
	waiting = list(instances)
	while len(waiting) > 0:
		for instance in waiting:
			if is_instance_terminated(instance) is False:
				continue
			print "\t%s is terminated, %d to go" % (instance, len(waiting))
			waiting.remove(instance)
		time.sleep(1)

	# TODO: fazer try catch pra um clean-exit por aqui
	# TODO: remover arquivo pem 

	print sheet

	print "Cleaning up group and keypair"
	group['obj'].delete()
	keypair['obj'].delete()
